
1. Символы в другой регистр
[освоить циклы, массивы, указатели, функцию touuper()]
На входе `char some_string[] = "some string"`

2. Вывод кириллицы
[освоить перевод локали, вывод символов на другом языке]

3. Поменять значения местами
[освоить указатели и ссылки]
Нужен вызов вроде `swap(&variable_1, &variable_2)`

4. Выделение массива по запросу и его заполнение от начального числа с шагом
[освоить ручное управление динамической памятью в лице выделения и очистки, попользоваться циклами]

5. Дан массив строк, нужно записать абзацы в обратном порядке
[больше практики с циклами и указателями, менее тривиальные счётчики, цикл с оглядкой назад, придумать логику решения]

6. Посчитать длину utf8-строки
[освоить кодировки, сохранить в visual studio файл в кодировке utf8, битовые операции, циклы, придумать логику решения]

7. Дан массив чисел длины N, в нём по одному разу, кроме одного, лежат числа в диапазоне [0,N) в случайном порядке, надо быстро (подсказка: за O(n)) найти 'неправильное' число
[якобы задача с собеседования, которую можно решить известными на сегодня средствами]

8. Ещё одна простая задача с собеседования. Простая в смысле что это базовый фильтр.
// Дана строка s, состоящая из нулей и единиц.
// Найти длину самой длинной сбалансированной подстроки s.
// Подстрока называется сбалансированной, если все нули идут до единиц,
//   и количество нулей равно количеству единиц.
// findTheLongestBalancedSubstring("01000111") => 6 // "000111"
// findTheLongestBalancedSubstring("00111") => 4 // "0011"

<iostream> - ввод-вывод (печать)
<cstdint> - целые числа со строгим размером
<clocale> - включение русского в visual studio
<cstring> - строки (strcmp(), strcpy() и т.п.)
<cctype> - класс ascii-символа и перевод заглавных-строчных
<cstdlib> - system("pause")
<cstddef> - size_t, std::byte (вместо uint8_t)
<iomanip> - доп.флаги форматирования
<climits> <cfloat> - максимальные значения



















