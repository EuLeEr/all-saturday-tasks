0. (из 3 задания) На рекурсию и понимание массивов. Написать функцию, которая принимает двумерный массив (`**`), и находит площадь фигуры. Пусть 'пустая клетка' обозначается точкой `.`, а 'занятая' - решёткой `#`. Исходный массив можно менять (полезно для обозначения посещённых клеток), но после нахождения площади изменений остаться не должно
1. Повторение ООП. Мы столько раз писали класс `Point`, а Вы его пробовали писать? Напишите `Point`, у которого есть конструктор по-умолчанию (без аргументов, x и y пусть 0 будут). И конструктор с аргументами. Оформите ему вывод на консоль через перегрузку оператора `<<`. Пусть все методы Point печатают что-то на консоль, например: конструктор - `Point{x: 0, y: 2} created`, деструктор - `Point{x: 0, y: 2} destroyed`. Напишите оператор присваивания одной точке другой, тоже с печатью на консоль. Оформите примеры. Дальше, оператор сложения двух точек, `x` одной точки складывается с `x` другой точки, `y` одной точки складывается с `y` другой, тоже с логами и примерами.
2. На классы. Написать класс двумерного массива, все элементы которого хранятся в одном векторе (с лекционной части). Понадобится вспомогательный класс `Row`.
3. Написать шаблонную перегрузку оператора `<<`, которая сможет печатать векторы любого уровня вложенности, для `int`. До тех пор, пока элемент массива - не `int`, шаблон вызывает себя же для элемента массива. Как только элемент массива будет `int`, этот шаблон должен попасть в специализацию для `int`, то есть это будет `template<> void print_nested_rec<int>(...stream, vec...)`, который и напечатает, собственно, элементы. На занятии сейчас уже написали.

_. Многомерный массив


