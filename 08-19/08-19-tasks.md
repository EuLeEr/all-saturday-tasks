0. На подумать. Как с помощью статической переменной и конструкторов получить тип данных (объект), у которого _всегда_ существует лишь _одна_ переменная? (используется static)
1. На строки и ввод-вывод. Считать из консоли настройки. Настройки - это массив строк вида `ключ1: значение1`, `ключ2: значение2`, который надо преобразовать в структуру `struct Settings {std::string переменная-ключ1 со значением "значение1"; std::string переменная-ключ2 со значением "значение2"}`. Огранизовать программу так, чтобы новые поля было несложно добавлять (считывать поля в цикле).
Пример: на входе
```
user makaleks
address pusk
```
```cpp
struct Config {
	std::string user; // "makaleks"
	std::string address; // "pusk"
}
```
2. Усовершенствовать чтение настроек: 1. позволить принимать пары "ключ-значение" в любом порядке 2. установить значения по-умолчанию (пусть за окончание ввода отвечает строка "END").
```
user makaleks
END
```
```cpp
struct Config {user == "makaleks", address == "default-address"}
```
----------------
```
address pusk
user makaleks
```
```cpp
struct Config {user == "makaleks", address == "pusk"}
```
3. На ввод-вывод и сортировку. Создать программу, которая считывает из консоли строки (в том числе с пробелами) до тех пор, пока не будет введена особая строка "END" - тогда программа должна распечатать считанные строки, отсортированные по-алфавиту. Пустые строки игнорировать. Сортировка `std::vector<std::string> all_strings` выполняется вызовом `std::sort(all_strings.begin(), all_strings.end())`, нужен `#include <algorithm>`
4. На рекурсию и понимание массивов. Написать функцию, которая принимает двумерный массив (`**`), и находит площадь фигуры. Пусть 'пустая клетка' обозначается точкой `.`, а 'занятая' - решёткой `#`. Исходный массив можно менять (полезно для обозначения посещённых клеток), но после нахождения площади изменений остаться не должно
5. На обход по указателям, использование очереди (`std::vector`, но можно самостоятельно познакомиться с `std::deque`), из собеседований. Есть дерево `struct Node { int value; Node *left_child_ptr; Node *right_child_ptr; }`. Нужно обойти дерево и построить `std::vector`, в которой по номеру уровня будет возвращена сумма `int value` со всех узлов на этом уровне.
6. На конструкторы и перегрузку операторов. Создать умный указатель по принципу 'счётчик ссылок'



